import{_ as s,r as a,o as t,c as d,a as e,b as i,d as n,f as r}from"./app-8ab1e15b.js";const o={},h=r('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="一、redis存储数据的结构" tabindex="-1"><a class="header-anchor" href="#一、redis存储数据的结构" aria-hidden="true">#</a> 一、Redis存储数据的结构</h2><p><strong>常用的5种数据结构：</strong></p><ul><li>key-string：一个key对应一个值。</li><li>key-hash：一个key对应一个Map。</li><li>key-list：一个key对应一个列表。 有序的 可以重复的</li><li>key-set：一个key对应一个集合。 无序的 不可以重复的</li><li>key-zset：一个key对应一个有序的集合。 有序的 不可以重复的</li></ul><p><strong>另外三种数据结构：</strong></p><ul><li>HyperLogLog：计算近似值的。</li><li>GEO：地理位置。</li><li>BIT：一般存储的也是一个字符串，存储的是一个byte[]。</li></ul><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011174043699.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ul><li>key-string：最常用的，一般用于存储<strong>一个值</strong>。</li><li>key-hash：存储一个<strong>对象</strong>数据的。</li><li>key-list：使用list结构实现栈和队列结构。</li><li>key-set：交集，差集和并集的操作。</li><li>key-zset：排行榜，积分存储等操作。</li></ul><h2 id="二、redis事物" tabindex="-1"><a class="header-anchor" href="#二、redis事物" aria-hidden="true">#</a> 二、Redis事物</h2><p>Redis的事务：一次事务操作，该成功的成功，该失败的失败。<br>先开启事务，执行一些系列命令，但是命令不会立即执行，会被放在一个队列中，如果你执行事务，那么这个队列中的命令全部执行，如果取消了事务，一个队列中的命令全部作废。</p><ul><li>开启事务：multi</li><li>输入要执行的命令：被放入到一个队列中</li><li>执行事务：exec</li><li>取消事务：discard</li></ul><p>在开启事务之前，先通过watch命令去监听一个或多个key，在开启事务之后，如果有其他客户端修改了我监听的key，事务会自动取消。 <br>如果执行了事务，或者取消了事务，watch监听自动消除，一般不需要手动执行unwatch。</p><h2 id="三、redis持久化机制" tabindex="-1"><a class="header-anchor" href="#三、redis持久化机制" aria-hidden="true">#</a> 三、Redis持久化机制</h2><p><strong>3.1 RDB</strong><br>RDB是Redis默认的持久化机制</p><ul><li>RDB持久化文件，速度比较快，而且存储的是一个二进制的文件，传输起来很方便。</li><li>RDB持久化的时机：save 900 1：在900秒内，有1个key改变了，就执行RDB持久化。save 300 10：在300秒内，有10个key改变了，就执行RDB持久化。save 60 10000：在60秒内，有10000个key改变了，就执行RDB持久化。</li><li>RDB无法保证数据的绝对安全。</li></ul><p><strong>3.2 AOF</strong><br>AOF持久化机制默认是关闭的，Redis官方推荐同时开启RDB和AOF持久化，更安全，避免数据丢失。</p><ul><li>AOF持久化的速度，相对RDB较慢的，存储的是一个文本文件，到了后期文件会比较大，传输困难。</li><li>AOF持久化时机。appendfsync always：每执行一个写操作，立即持久化到AOF文件中，性能比较低。<br>appendfsync everysec：每秒执行一次持久化。<br>appendfsync no：会根据你的操作系统不同，环境的不同，在一定时间内执行一次持久化。</li><li>AOF相对RDB更安全，推荐同时开启AOF和RDB。</li></ul><p><strong>注意事项</strong><br>同时开启RDB和AOF的注意事项：<br>如果同时开启了AOF和RDB持久化，那么在Redis宕机重启之后，需要加载一个持久化文件，优先选择AOF文件。<br>如果先开启了RDB，再次开启AOF，如果RDB执行了持久化，那么RDB文件中的内容会被AOF覆盖掉。<br>或者是：建议redis配置完成后，同时开启RDB和AOF备份！</p><h2 id="四、redis常见问题【重点】" tabindex="-1"><a class="header-anchor" href="#四、redis常见问题【重点】" aria-hidden="true">#</a> 四、Redis常见问题【重点】</h2><h3 id="_4-1-key的生存时间到了-redis会立即删除吗" tabindex="-1"><a class="header-anchor" href="#_4-1-key的生存时间到了-redis会立即删除吗" aria-hidden="true">#</a> 4.1 key的生存时间到了，Redis会立即删除吗？</h3><p>不会立即删除。</p><ul><li>定期删除：Redis每隔一段时间就去会去查看Redis设置了过期时间的key，会再100ms的间隔中默认查看3个key。</li><li>惰性删除：如果当你去查询一个已经过了生存时间的key时，Redis会先查看当前key的生存时间，是否已经到了，直接删除当前key，并且给用户返回一个空值。</li></ul><h3 id="_4-2-redis的淘汰机制" tabindex="-1"><a class="header-anchor" href="#_4-2-redis的淘汰机制" aria-hidden="true">#</a> 4.2 Redis的淘汰机制</h3><p>在Redis内存已经满的时候，添加了一个新的数据，执行淘汰机制。</p><ul><li>volatile-lru：在内存不足时，Redis会在设置过了生存时间的key中干掉一个最近最少使用的key。</li><li>allkeys-lru：在内存不足时，Redis会再全部的key中干掉一个最近最少使用的key。</li><li>volatile-lfu：在内存不足时，Redis会再设置过了生存时间的key中干掉一个最近最少频次使用的key。</li><li>allkeys-lfu：在内存不足时，Redis会再全部的key中干掉一个最近最少频次使用的key。</li><li>volatile-random：在内存不足时，Redis会再设置过了生存时间的key中随机干掉一个。</li><li>allkeys-random：在内存不足时，Redis会再全部的key中随机干掉一个。</li><li>volatile-ttl：在内存不足时，Redis会在设置过了生存时间的key中干掉一个剩余生存时间最少的key。</li><li>noeviction：（默认）在内存不足时，直接报错。</li></ul>',25),g={href:"http://i.heyige.cn/devops/redis.html",target:"_blank",rel:"noopener noreferrer"},c=e("br",null,null,-1),p=e("br",null,null,-1),b=e("br",null,null,-1),u=e("br",null,null,-1),y=e("br",null,null,-1),k=e("br",null,null,-1),R=r('<h3 id="_4-3-缓存的常问题" tabindex="-1"><a class="header-anchor" href="#_4-3-缓存的常问题" aria-hidden="true">#</a> 4.3 缓存的常问题</h3><p><strong>缓存穿透</strong><br>个人理解：指查询一个一定不存在的数据，由于缓存是不命中的，将去查询数据库，但是数据库也没有这个数据，更糟糕的是我们没有把这次查询的 null 结果 写入缓存，这将导致这个不存在的数据每次查询 都走数据库。 缓存也就没有意义了<br>风险: 利用不存在的数据 进行攻击 数据库瞬时压力增大 可能导致崩溃<br>解决：<strong>将null 结果放入 缓存 ，最好 加入一个 过期时间</strong><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011174108678.png" alt="image.png" loading="lazy"><br><strong>缓存击穿</strong><br>个人理解：对于某些热点数据 可能设置了过期时间 或者 在 第一次访问之前缓存中没有 在某一刻的高并发访问 都没有命中缓存，都查询了数据库 这称之为 缓存击穿<br>解决方案：加锁<br>预先设置下热点数据<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011174144426.png" alt="image.png" loading="lazy"><br><strong>缓存雪崩问题</strong><br>缓存雪崩<br>个人理解：我们在设置缓存的 key 时 采用了相同的过期时间 导致缓存在某一时刻同时失效 请求全部转到数据库 数据库瞬时压力大 造成雪崩<br>解决方案：设置key 的时候 在原有的过期时间上 加上一个 随机值 比如 1-5 分钟的随机值 这样 每一个缓存key 的过期时间 重复率就会降低<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011174128973.png" alt="image.png" loading="lazy"></p><h2 id="五、延迟双删" tabindex="-1"><a class="header-anchor" href="#五、延迟双删" aria-hidden="true">#</a> 五、延迟双删</h2><p>redis延迟双删的策略<br>1.为什么要进行延迟双删<br>一般我们在更新数据库数据时，需要同步redis中缓存的数据<br>所以存在两种方法：<br>（1）第一种方案：先执行update操作，再执行缓存清除。<br>（2）第二种方案：先执行缓存清除，再执行update操作。<br>弊端:当存在并发请求时，很容易出现问题<br>（1）第一种方案：当请求1执行update操作后，还未来得及进行缓存清除，此时请求2查询到并使用了redis中的旧数据。<br>（2）第二种方案：当请求1执行清除缓存后，还未进行update操作，此时请求2进行查询到了旧数据并写入了redis。<br>2.如何实现延迟双删<br>所以此时我们需要使用第三种方案：<br>先进行缓存清除，再执行update，最后（延迟N秒）再执行缓存清除。<br>3.需要注意的点<br>上述中（延迟N秒）的时间要大于一次写操作的时间，一般为3-5秒。<br>原因：如果延迟时间小于写入redis的时间，会导致请求1清除了缓存，但是请求2缓存还未写入的尴尬</p><h2 id="六、哨兵模式" tabindex="-1"><a class="header-anchor" href="#六、哨兵模式" aria-hidden="true">#</a> 六、哨兵模式</h2><p>哨兵模式 主节点 挂掉之后 在从机中选出新的主节点，哪个从机会被选为新的主节点？<br>根据 配置文件的replica-priority 100 这个配置 这个值越小 优先级越高<br>哨兵 解决了单点故障的问题 当有一个 master 节点 挂掉了 自动投票选举 出来一个 master 保证 主从架构正常执行 但是 这种架构还有一种问题 就是 存储的数据有限 ，也就是当数据量很大的时候 一个redis 存不下，上面的 一个 redis 主节点 无法存储这么多的数据 此时 就需要集群了<br>Redis集群在保证主从加哨兵的基本功能之外，还能够提升Redis存储数据的能力</p>',6);function m(_,f){const l=a("ExternalLinkIcon");return t(),d("div",null,[h,e("p",null,[e("a",g,[i("指定淘汰机制的方式：maxmemory-policy 具体策略，设置Redis的最大内存：maxmemory 字节大小"),n(l)]),c,i("内存配置"),p,i("(1)、内存设置"),b,i("①、如果不设置内存大小或者设置内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存。"),u,i("②、Redis一般推荐设置内存为最大物理内存的四分之三。"),y,i("(2)、修改文件配置"),k,i("修改maxmemory大小，单位字节")]),R])}const x=s(o,[["render",m],["__file","Redis.html.vue"]]);export{x as default};

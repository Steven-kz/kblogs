const e=JSON.parse('{"key":"v-ff7e7708","path":"/java/DesignPattern/proxy.html","title":"代理模式","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2022-01-04T00:00:00.000Z","lastUpdated":true,"contributors":true,"description":"代理模式 代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，解耦。 一、静态代理 静态代理相当于是多写了一个代理类，在调用的时候调用的是代理类，在代理类中的处理还是原生的处理逻辑，不过在前后添加上需要添加的代码。 缺点：需要为每一个被代理的对象都创建一个代理类。 白话： 代理角色和真实角色都需要实现同一个接口 真实角色专注于自己的事情 代理角色目的就是帮助真实角色完成一件事情 实现一个接口Runnable 使用的就是\\"静态代理\\"的思想","head":[["meta",{"property":"og:url","content":"https://k-flower.gitee.io/kblogs/java/DesignPattern/proxy.html"}],["meta",{"property":"og:site_name","content":"Flowers"}],["meta",{"property":"og:title","content":"代理模式"}],["meta",{"property":"og:description","content":"代理模式 代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，解耦。 一、静态代理 静态代理相当于是多写了一个代理类，在调用的时候调用的是代理类，在代理类中的处理还是原生的处理逻辑，不过在前后添加上需要添加的代码。 缺点：需要为每一个被代理的对象都创建一个代理类。 白话： 代理角色和真实角色都需要实现同一个接口 真实角色专注于自己的事情 代理角色目的就是帮助真实角色完成一件事情 实现一个接口Runnable 使用的就是\\"静态代理\\"的思想"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-11-01T03:15:53.000Z"}],["meta",{"property":"article:author","content":"Kou"}],["meta",{"property":"article:published_time","content":"2022-01-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-11-01T03:15:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代理模式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-01-04T00:00:00.000Z\\",\\"dateModified\\":\\"2025-11-01T03:15:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Kou\\"}]}"]]},"headers":[{"level":2,"title":"一、静态代理","slug":"一、静态代理","link":"#一、静态代理","children":[]},{"level":2,"title":"二、JDK动态代理和CGLIB代理区别","slug":"二、jdk动态代理和cglib代理区别","link":"#二、jdk动态代理和cglib代理区别","children":[]},{"level":2,"title":"三、JDK动态代理","slug":"三、jdk动态代理","link":"#三、jdk动态代理","children":[]},{"level":2,"title":"四、CgLib代理","slug":"四、cglib代理","link":"#四、cglib代理","children":[]},{"level":2,"title":"","slug":"","link":"#","children":[]}],"git":{"createdTime":1696925569000,"updatedTime":1761966953000,"contributors":[{"name":"kou","email":"knightbreeze@163.com","commits":3}]},"readingTime":{"minutes":4.58,"words":1374},"filePathRelative":"java/DesignPattern/proxy.md","localizedDate":"2022年1月4日","excerpt":"<h1> 代理模式</h1>\\n<p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能，解耦。</p>\\n<h2> 一、静态代理</h2>\\n<p>静态代理相当于是多写了一个代理类，在调用的时候调用的是代理类，在代理类中的处理还是原生的处理逻辑，不过在前后添加上需要添加的代码。<br>\\n缺点：需要为每一个被代理的对象都创建一个代理类。<br>\\n白话：<br>\\n代理角色和真实角色都需要实现同一个接口<br>\\n真实角色专注于自己的事情<br>\\n代理角色目的就是帮助真实角色完成一件事情<br>\\n实现一个接口Runnable 使用的就是\\"静态代理\\"的思想</p>","autoDesc":true}');export{e as data};

import{_ as a,o as e,c as h,f as s}from"./app-8ab1e15b.js";const r={},t=s('<h1 id="关于集合" tabindex="-1"><a class="header-anchor" href="#关于集合" aria-hidden="true">#</a> 关于集合</h1><p><strong>什么是集合</strong></p><ul><li>集合就是一个存放数据对象引用的容器</li><li>集合类存放的都是对象的引用，而不是对象的本身</li><li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li></ul><p><strong>集合和数组的区别</strong></p><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><p><strong>常用的集合类有哪些</strong></p><p>Map接口和Collection接口是所有集合框架的父接口：<br> Collection接口的子接口包括：Set接口和List接口</p><blockquote><p>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等<br> Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等<br> List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</p></blockquote><h1 id="一、list" tabindex="-1"><a class="header-anchor" href="#一、list" aria-hidden="true">#</a> 一、List</h1><h2 id="_1-1-arraylist-底层object数组" tabindex="-1"><a class="header-anchor" href="#_1-1-arraylist-底层object数组" aria-hidden="true">#</a> 1.1 Arraylist：底层Object数组</h2><p>初始化长度10，扩容原容量的1.5倍。</p><p>优点：</p><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</p><p>ArrayList 在顺序添加一个元素的时候非常方便。</p><p>缺点：</p><p>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</p><p>插入元素的时候，也需要做一次元素复制操作，缺点同上。</p><p><strong>ArrayList 比较适合顺序添加、查寻角较多场景。</strong></p><h2 id="_1-2-linkedlist-双向循环链表" tabindex="-1"><a class="header-anchor" href="#_1-2-linkedlist-双向循环链表" aria-hidden="true">#</a> 1.2 LinkedList： 双向循环链表</h2><p>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快<strong>查询较慢，插入和删除操作较多时，更推荐使用 LinkedList</strong></p><h2 id="_1-3-vector-object数组" tabindex="-1"><a class="header-anchor" href="#_1-3-vector-object数组" aria-hidden="true">#</a> 1.3 Vector： Object数组</h2><p>线程安全 加了 synchronized 修饰性能差。</p><p>扩容机制： Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</p><h1 id="二、set" tabindex="-1"><a class="header-anchor" href="#二、set" aria-hidden="true">#</a> 二、Set</h1><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key，HashSet 的操作，基本上都是直接调用底层HashMap 的相关方法来完成，HashSet 不允许重复的值。</p><h2 id="_2-1-hashset-无序-唯一" tabindex="-1"><a class="header-anchor" href="#_2-1-hashset-无序-唯一" aria-hidden="true">#</a> 2.1 HashSet （无序，唯一）</h2><p>基于 HashMap 实现的，底层采用 HashMap 来保存元素</p><p><strong>HashSet如何检查重复</strong></p><ul><li>HashSet 中的add ()方法会使用HashMap 的put()方法。</li><li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equles</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p><strong>hashCode（）与equals（）的相关规定：</strong></p><p>如果两个对象相等，则hashcode一定也是相同的</p><ul><li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值<br> 两个对象相等,对两个equals方法返回true<br> 两个对象有相同的hashcode值，它们也不一定是相等的<br> 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖<br> hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个<br> 对象无论如何都不会相等（即使这两个对象指向相同的数据）。<br> ==与equals的区别</li></ul><p>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同<br> ==是指对内存地址进行比较 equals()是对字符串的内容进行比较</p></div><h2 id="_2-2-linkedhashset" tabindex="-1"><a class="header-anchor" href="#_2-2-linkedhashset" aria-hidden="true">#</a> 2.2 LinkedHashSet</h2><p>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</p><h2 id="_2-3-treeset-有序-唯一" tabindex="-1"><a class="header-anchor" href="#_2-3-treeset-有序-唯一" aria-hidden="true">#</a> 2.3 TreeSet （有序，唯一）</h2><p>红黑树(自平衡的排序二叉树)</p><h1 id="三、map" tabindex="-1"><a class="header-anchor" href="#三、map" aria-hidden="true">#</a> 三、Map</h1><h2 id="_3-1-hashmap" tabindex="-1"><a class="header-anchor" href="#_3-1-hashmap" aria-hidden="true">#</a> 3.1 HashMap</h2><p>JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是<br> 主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较<br> 大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p><h2 id="_3-2-linkedhashmap" tabindex="-1"><a class="header-anchor" href="#_3-2-linkedhashmap" aria-hidden="true">#</a> 3.2 LinkedHashMap</h2><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散<br> 列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加<br> 了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的<br> 操作，实现了访问顺序相关逻辑</p><h2 id="_3-3-hashtable" tabindex="-1"><a class="header-anchor" href="#_3-3-hashtable" aria-hidden="true">#</a> 3.3 HashTable</h2><p>数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突<br> 而存在的 <strong>（线程安全）</strong></p><h2 id="_3-4-treemap" tabindex="-1"><a class="header-anchor" href="#_3-4-treemap" aria-hidden="true">#</a> 3.4 TreeMap</h2><p>红黑树（自平衡的排序二叉树）</p><h1 id="四、常见问题" tabindex="-1"><a class="header-anchor" href="#四、常见问题" aria-hidden="true">#</a> 四、常见问题</h1><h2 id="hashset与hashmap的区别" tabindex="-1"><a class="header-anchor" href="#hashset与hashmap的区别" aria-hidden="true">#</a> HashSet与HashMap的区别</h2>',45),i=[t];function d(n,p){return e(),h("div",null,i)}const o=a(r,[["render",d],["__file","Collection.html.vue"]]);export{o as default};

import{_ as r,o as e,c as t,f as g}from"./app-8ab1e15b.js";const i={},n=g('<h1 id="观察者模式" tabindex="-1"><a class="header-anchor" href="#观察者模式" aria-hidden="true">#</a> 观察者模式</h1><p>spring事件就是观察者模式的一种 ，是一种行为设计模式，它定义了对象之间的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并被自动更新。在这个模式中，改变状态的对象被称为主题，依赖的对象被称为观察者。<br>举个实际的例子：<br><strong>事件源（Event Source）</strong>：可以视为“主题（Subject）”，当其状态发生变化时（比如播放新的内容），会通知所有的观察者。想象我们正在听广播，广播电台就是一个事件源，它提供了大量的新闻、音乐和其他内容。<br><strong>事件（Event）</strong>：这是主题状态改变的具体表示，对应到广播例子中，就是新闻、音乐和其他内容。每当电台播放新的内容时，就相当于一个新的事件被发布了。<br><strong>广播器（Event Publisher / Multicaster）</strong>：广播器起到的是中介的作用，它将事件从事件源传递到监听器。在这个例子中，广播塔就充当了这个角色，它将电台的节目的无线电信号发送到空气中，以便无线电接收器（监听器）可以接收。<br><strong>监听器（Listener）</strong>：监听器就是“观察者”，它们监听并响应特定的事件。在例子中，无线电接收器就是监听器，它接收广播塔发出的信号，然后播放电台的内容。<br><strong>在Spring中，事件模型的工作方式也是类似的：</strong><br>当Spring应用程序中发生某个行为时（比如一个用户完成了注册），那么产生这个行为的组件（比如用户服务）就会创建一个事件，并将它发布出去。<br>事件一旦被发布，Spring的ApplicationContext就会作为广播器，把这个事件发送给所有注册的监听器。<br>各个监听器接收到事件后，就会根据事件的类型和内容，进行相应的处理（比如发送欢迎邮件，赠送新用户优惠券等）。<br>  这就是Spring事件模型的工作原理，它实现了事件源、广播器和监听器之间的解耦，使得事件的生产者和消费者可以独立地进行开发和修改，增强了程序的灵活性和可维护性。</p><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011170412973.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="观察者模式-1" tabindex="-1"><a class="header-anchor" href="#观察者模式-1" aria-hidden="true">#</a> 观察者模式</h2><p>观察者模式是一种对象行为模式。它定义对象间的一种一对多的依赖关系(被观察者维护观察者列表)当一个对象的状态发生改变时，列表中所有观察者都会接收到状态改变的通知观察者把自己注册到被观察者持有的列表中由被观察者轮询调用观察者的处理代码当被观察者发布通知，也就是有事件触发时，由被观察者轮询调用观察者的处理代码<img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011170427056.png" alt="image.png" loading="lazy"><br>ps：观察者和被观察者要存在依赖关系<br>2.发布订阅模式<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011170452988.png" alt="image.png" loading="lazy"><br>ps：发布者不知道订阅者的存在，存在消息管理器，彼此不知道对方存在.<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011170439441.png" alt="image.png" loading="lazy"><br>策略模式优缺点<br>1）优点<br>策略模式提供了对“开闭原则”的完美支持，用户可以在不 修改原有系统的基础上选择算法或行为，也可以灵活地增加 新的算法或行为。<br>策略模式提供了管理相关的算法族的办法。<br>策略模式提供了可以替换继承关系的办法。<br>使用策略模式可以避免使用多重条件转移语句。<br>2）缺点<br>策略模式将造成产生很多策略类，可以通过使用享元模式在一 定程度上减少对象的数量。</p>',5),a=[n];function s(o,c){return e(),t("div",null,a)}const p=r(i,[["render",s],["__file","gcz.html.vue"]]);export{p as default};

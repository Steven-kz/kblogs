import{_ as a,o as n,c as s,f as e}from"./app-8ab1e15b.js";const t={},r=e(`<h1 id="jdk1-8新特性" tabindex="-1"><a class="header-anchor" href="#jdk1-8新特性" aria-hidden="true">#</a> JDK1.8新特性</h1><h2 id="_1-1lomdba" tabindex="-1"><a class="header-anchor" href="#_1-1lomdba" aria-hidden="true">#</a> 1.1Lomdba</h2><p>lomdba表达式就是使代码更简洁，它的本质就是作为函数式接口的实例，代替匿名内部类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//语法格式：(参数名)-&gt;{⽅法实现}</span>
<span class="token class-name">Runnable</span> r2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我爱北京天安门&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r2<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-2函数式接口" tabindex="-1"><a class="header-anchor" href="#_1-2函数式接口" aria-hidden="true">#</a> 1.2函数式接口</h2><p>如果一个<strong>接口中</strong>，有且仅有<strong>一个抽象方法</strong>，<strong>则此接口就称为函数式接口</strong>。我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口</p><h2 id="_1-3stream" tabindex="-1"><a class="header-anchor" href="#_1-3stream" aria-hidden="true">#</a> 1.3Stream</h2><p>真正的引入了函数编程，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何_CRUD。_它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用</p><ol><li>stream 串行流</li><li>parallelStream 并行流，可多线程执行</li></ol><h2 id="_1-4optional" tabindex="-1"><a class="header-anchor" href="#_1-4optional" aria-hidden="true">#</a> 1.4Optional</h2><p>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。<br> Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><h2 id="_1-5新时间日期api" tabindex="-1"><a class="header-anchor" href="#_1-5新时间日期api" aria-hidden="true">#</a> 1.5新时间日期API</h2><p>LocalDateTime、LocalDate、LocalTime</p><h2 id="_1-6接口默认-静态方法" tabindex="-1"><a class="header-anchor" href="#_1-6接口默认-静态方法" aria-hidden="true">#</a> 1.6接口默认/静态方法</h2><p>⽅法可以⽤ default 或 static 修饰</p><h2 id="_1-7重复注解-类型注解" tabindex="-1"><a class="header-anchor" href="#_1-7重复注解-类型注解" aria-hidden="true">#</a> 1.7重复注解/类型注解</h2><p><strong>重复注解：</strong><br> 允许在同一声明类型（类，属性，或方法）上多次使用同一个注解。<br> Java8以前的版本使用注解有一个限制是相同的注解在同一位置只能使用一次，不能使用多次。<br> Java 8 引入了重复注解机制，这样相同的注解可以在同一地方使用多次。重复注解机制本身必须用 @Repeatable 注解<br><strong>类型注解：</strong><br> 在java 8之前，注解只能是在声明的地方所使用，java8开始，注解可以应用在任何地方。</p><h2 id="_1-8hashmap-concurrenthashmap底层结构" tabindex="-1"><a class="header-anchor" href="#_1-8hashmap-concurrenthashmap底层结构" aria-hidden="true">#</a> 1.8HashMap/ConcurrentHashMap底层结构</h2><p>略</p>`,19),o=[r];function i(p,c){return n(),s("div",null,o)}const d=a(t,[["render",i],["__file","JDK.html.vue"]]);export{d as default};

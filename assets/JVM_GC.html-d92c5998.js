import{_ as s,r as o,o as l,c as r,a as n,b as t,d as a,f as i}from"./app-8ab1e15b.js";const c={},g=i('<h1 id="jvm-gc" tabindex="-1"><a class="header-anchor" href="#jvm-gc" aria-hidden="true">#</a> JVM_GC</h1><h1 id="一、jvm运行时数据区域" tabindex="-1"><a class="header-anchor" href="#一、jvm运行时数据区域" aria-hidden="true">#</a> 一、JVM运行时数据区域</h1><p>JDK1.7：程序计数器、虚拟机栈、本地⽅法栈、堆、⽅法区<br>JDK1.8：程序计数器、虚拟机栈、本地⽅法栈、堆、元空间<img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011164721108.png" alt="image.png" loading="lazy"><br><strong>程序计数器</strong>：记录每个线程的执⾏的字节⾏数。线程私有 <br><strong>虚拟机栈</strong>：方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出，就是记录运行时需要的内存空间，方法参数。线程私有<br><strong>本地方法栈</strong>： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，其他都与虚拟机栈一致。线程私有<br><strong>堆</strong>：记录⼤部分对象存储所需要的空间，最复杂的内存区域，内部分为：新⽣代（伊甸区+幸存者区 <br>1+幸存者区2）和⽼年代 <br><strong>方法区（1.7）</strong>：存储类的信息（编译字节、静态区（静态变量、⽅法）、⽅法）和常量池 <br><strong>元空间（1.8）</strong>：没有在JVM内存区，⽽是直接使⽤电脑的内存区，存储类的信息（编译字节、静态区 （静态变量、⽅法）、⽅法）和常量池 <br>直接内存：没有在JVM内存区，⽽是直接使⽤电脑的内存区，NIO有个Buffer,有⼀个叫直接内存 <br>栈管运⾏，堆管存储。则虚拟机栈负责运⾏代码，⽽虚拟机堆负责存储数据</p><h1 id="二、jvm堆内存" tabindex="-1"><a class="header-anchor" href="#二、jvm堆内存" aria-hidden="true">#</a> 二、JVM堆内存</h1><p><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011164819307.png" alt="image.png" loading="lazy"><br>堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong></p><h3 id="讲下gc" tabindex="-1"><a class="header-anchor" href="#讲下gc" aria-hidden="true">#</a> 讲下gc</h3><p><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011174414.png" alt="image.png" loading="lazy"><br>判断对象是否存活<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011164841035.png" alt="image.png" loading="lazy"><br>GCRoots就是对象，是JVM确定当前绝不会被回收的对象（静态属性的对象）</p><h3 id="_5、完整gc回收流程-从创建到回收" tabindex="-1"><a class="header-anchor" href="#_5、完整gc回收流程-从创建到回收" aria-hidden="true">#</a> 5、完整GC回收流程 从创建到回收</h3>',8),_=n("br",null,null,-1),h=n("strong",null,"对象晋升到老年代一共有四种情况",-1),d=n("br",null,null,-1),u=n("br",null,null,-1),b=n("br",null,null,-1),m=n("br",null,null,-1),p=n("br",null,null,-1),v=n("strong",null,"GC回收算法",-1),f=n("br",null,null,-1),V=n("strong",null,"1.标记清除算法",-1),x=n("br",null,null,-1),J=n("br",null,null,-1),k=n("strong",null,"2.复制算法",-1),z=n("br",null,null,-1),B=n("br",null,null,-1),C=n("strong",null,"3.标记整理算法",-1),M=n("br",null,null,-1),G=n("br",null,null,-1),I=n("strong",null,"4.分代收集算法",-1),j=n("br",null,null,-1),N=n("br",null,null,-1),y={href:"https://blog.csdn.net/carson0408/article/details/79608686",target:"_blank",rel:"noopener noreferrer"},E=n("br",null,null,-1);function S(D,K){const e=o("ExternalLinkIcon");return l(),r("div",null,[g,n("p",null,[t("添加一个对象时，然后伊甸区的内存不足，直接添加到老年代中，当伊甸区内存不足时会发生gc时，就会把伊甸区存活对象和幸存者1存货的对象放到幸存者2上，然后将需要回收的对象回收之后，幸存者1和幸存者2区交换位置。然后他的年龄会+1，如果到达15岁就会进入到老年代。如果这块幸存者1内存不够，那么依赖老年代进行担保，直接进入老年代.还有一中情况就是 如果超过幸存者区一半的大小，就认为是大对象，存入老年代"),_,h,d,t("1.对象太大，Eden放不下 "),u,t("2.存放存活对象的Survivor区太小，不足以存下存活对象"),b,t("3.经历超过默认15次gc或者设定的"),m,t("4.判断是不是大对象-->看Survivor一半的大小，只要超过一般就认为是大对象，存入老年代"),p,v,f,V,x,t("将所有需要回收的算法进行标记，然后清除；这种算法的缺点是：效率比较低；标记清除后会出现大量不连续的内存碎片，这些碎片太多可能会使存储大对象会触发GC回收，造成内存浪费以及时间的消耗。"),J,k,z,t("将可用的内存分成两份，每次使用其中一块，当这块回收之后把未回收的复制到另一块内存中，然后把使用的清除。这种算法运行简单，解决了标记-清除算法的碎片问题，但是这种算法代价过高，需要将可用内存缩小一半，对象存活率较高时，需要持续的复制工作，效率比较低。"),B,C,M,t("将需要清理的对象进行标记，不直接清理，而是使存活对象往一端游走，然后清除一端边界以外的内存，这样既可以避免不连续空间出现，还可以避免对象存活率较高时的持续复制。这种算法适合老生代。"),G,I,j,t("分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代，在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以使用标记整理算法。"),N,n("a",y,[E,a(e)])])])}const O=s(c,[["render",S],["__file","JVM_GC.html.vue"]]);export{O as default};

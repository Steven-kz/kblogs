import{_ as e,o as n,c as r,f as s}from"./app-314de074.js";const a={},t=s(`<h1 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h1><p>是⼀种可以提升查询效率的结构，⽬的就是为了提⾼查询的效率</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code>创建索引：<span class="token keyword">create</span> <span class="token keyword">index</span> 索引名 <span class="token keyword">on</span> 表名<span class="token punctuation">(</span>字段名<span class="token punctuation">)</span> <span class="token punctuation">;</span> （id性能最高） 
创建表时候也可创建索引
查看索引是否⽣效：<span class="token keyword">explain</span> 查询语句 <span class="token keyword">where</span> 索引字段<span class="token operator">=</span>值<span class="token punctuation">;</span> 
删除索引：<span class="token keyword">alter</span> <span class="token keyword">table</span> 表名 <span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名<span class="token punctuation">;</span> 
查看表上的索引：<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> 表名<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>索引的分类：<br><strong>1.聚簇索引 也就是我们常用的id</strong><br><strong>2.普通索引</strong><br><strong>3.唯⼀索引(UNIQUE)</strong><br><strong>4.联合索引</strong><br><a name="dInYy"></a></p><h2 id="一、索引底层" tabindex="-1"><a class="header-anchor" href="#一、索引底层" aria-hidden="true">#</a> 一、索引底层</h2><p><strong>B-Tree</strong><br> B树的每一个结点都存储了key(索引值) 和 value(对应数据)<br>不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要回旋查询，效率低<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011164449.png" alt="img.png" loading="lazy"><br><strong>B+Tree</strong><br>底层有一个单项链表(从小排序的)，也就是叶子节点，存储了索引值和数据地址。<br>非叶子节点只存放索引值。<br>优点：查询速度快，当有排序的时候不需要进行回旋查找<br><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160437.png" alt="image.png" loading="lazy"><br><a name="Fumvp"></a></p><h2 id="二、索引失效原理" tabindex="-1"><a class="header-anchor" href="#二、索引失效原理" aria-hidden="true">#</a> 二、索引失效原理</h2><div class="hint-container warning"><p class="hint-container-title">索引失效分类</p><p>不符合最左匹配规则的原理<br>使用函数<br>%Like<br>使用Or导致索引失效<br>in使用不当<br>order By</p></div><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160500.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><ol><li>主要是联合索引 举几个例子 ，定义一个联合索引为 (a,b) ，联合索引查找的原理就是最左匹配原则，当a相等时，b的值也是有序的，这个时候根据二分法也是可以找到b对应的值，但是如果只查找b值的话，那就不存在a，那么b就是无序的，是没办法使用索引的，只能进行全表扫描，这种情况针对最左匹配原则</li><li>还有一个经典案例就是 当查询的第一个a值使用大于小于号的时候，a得值就是不确定的，那么b的值也就是无序的，无法使用索引，这里是不能使用&lt;&gt;号的。<br><a name="TWUBg"></a></li></ol><h2 id="三、innodb存储原理" tabindex="-1"><a class="header-anchor" href="#三、innodb存储原理" aria-hidden="true">#</a> 三、InnoDB存储原理</h2><div class="hint-container tip"><p class="hint-container-title">说明</p><p>1.聚簇索引(主键索引) 非叶子节点存储的key就是主键值，页子节点存储的key是主键值,value就是这一行的数据。<br>2.而其他索引的非叶子节点存的索引值是对应的值，叶子节点的value存储的是主键key，在根据主键key来一次聚簇索引拿到数据，所以这就是不推荐使用select * 的原因。<br></p></div><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/20231011160521.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="四、索引优化" tabindex="-1"><a class="header-anchor" href="#四、索引优化" aria-hidden="true">#</a> 四、索引优化</h2><p>1.首先我们在开发中要避免使用select *</p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>1.增加查询分析器解析*的成本<br><br> 2.无用的字段增加网络消耗，尤其是text类型的字段<br><br> 3.我们通过sql执行计划EXPLAIN可以看到select * 没有用到任何索引的情况下，查询效率非常低(举个例子：<br> select * from test where user_name = &#39;11&#39;，<br> 这一行查询，如果说有user_name这个索引，他首先能查到这条数据 根据索引存储的 存储的key是user_name的值 value是id值，<br> 然后再回旋查询，(这个做的实际上还是回表的操作，通过id实际上是拿到了整条数据进行了一个回表的操作，只有覆盖索引才不会进行回表操作)根据id值去匹配聚簇索引，key是id值，value是这一行的数据<br> 如果没有user_name的索引，那就是全表扫。聚簇索引就是主键索引 默认都有,所以select * 全表扫描的时候 如果没有索引那么效率会非常低)<br><br> 4.如果我们只查询自己用到的列，并且这些列都用到了索引(联合索引)，查询列都是索引列那么这些列被称为覆盖索引。这种情况下查询的相关字段都能走索引，索引查询的效率相对较高<br><br> 5.SELECT *操作在某些情况下可能会导致回表 在关联查询中，数据库系统可能会首先对一个表进行全表扫描，以减少后续连接操作的数据量。这是因为全表扫描通常比使用索引更高效，尤其是在表很大的情况下。然后，数据库系统会使用连接操作将扫描到的数据与另一个表的数据进行关联。<br><br> 如果查询的列超出了索引的范围，即查询中使用的列不完全是索引列，那么在连接操作之后，数据库系统可能需要回表到原始表中，以获取查询中使用的所有列的数据。这种情况下，回表操作会导致额外的I/O操作，从而降低查询性能。</p></div><p>2.小表驱动大表</p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>小表驱动大表就是指用数据量较小、索引比较完备的表，然后使用其索引和条件对大表进行数据筛选，从而减少数据计算量，提高查询效率。比如说student表有30条数据, scores表有80w条数据。我们就要把student作为主表，然后去关联scores的studentId。但如果相反的我们把scores作为主表，那么我们首先要把80w数据全部查出来性能肯定是大大降低了的</p></div><p>3.导致索引失效的情况</p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>1.不满足索引的前缀条件：如果索引是复合索引（即多列索引），并且查询没有使用索引列的前缀，那么索引可能不会被使用。例如，如果索引是 (a, b)，但查询只使用了 b，则索引可能失效。<br><br> 2.函数和表达式：在查询中使用函数（如 NOW()、YEAR() 等）或表达式（如计算、字符串拼接等）对索引列进行处理，会导致索引失效。<br><br> 3.模糊查询：对于类似于 LIKE &#39;%value%&#39; 的查询，如果通配符 % 出现在模式字符串的开始处，索引将不会被使用。<br><br> 4.使用 OR 连接的条件：当查询条件使用 OR 连接时，如果 OR 两边的条件没有使用同一个索引，或者其中一个条件没有索引，那么索引可能失效。<br><br> 4.复合索引的顺序问题：如果查询条件中的列与复合索引中的列顺序不一致，那么索引可能不会被有效利用。<br><br> 5.列的隐式类型转换：当查询条件中的列与索引列类型不匹配时，可能会导致类型转换，从而使索引失效。<br><br> 6.使用 NOT、&lt;&gt;、IS NULL、IS NOT NULL 等操作符：这些操作符可能导致索引失效，因为它们往往涉及到全表扫描。<br><br> 7.索引列上的计算：在索引列上进行计算（如 age + 1 = 30）会导致索引失效。<br><br> 8.使用 IN 和 NOT IN 时：当 IN 或 NOT IN 列表中的元素过多时，数据库可能会选择全表扫描而不是使用索引。<br><br> 9.索引的选择性较低：如果索引列的区分度不高（即许多行具有相同的索引值），数据库可能会选择全表扫描。<br><br> 10.覆盖索引未使用：如果查询的列没有完全被索引覆盖，那么即使存在索引，数据库也可能选择全表扫描。<br><br> 11.数据库统计信息不准确：如果数据库的统计信息不准确，查询优化器可能会做出错误的索引选择决策。<br><br> 12.强制索引：有时开发者可能会强制使用特定的索引，但如果使用的索引不是最优的，可能会导致性能下降。<br></p></div><p>4.explain关键字<br> 通过explain关键字可以看到sql语句的执行过程，其中type、key、key_len、Extra需要尤其注重<br><img src="https://cdn.jsdelivr.net/gh/OliverLiy/DrawingBed/myblog/11-6-1.png" alt="image.png" loading="lazy"></p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>id<br> 标识符<br><br> 如果有多个id，id值相同，顺序执行；id值不同，id值越大越优先查询<br><br> 1.select_type：查询类型<br><br> 2.primary：包含子查询SQL中的主查询（最外层）<br><br> 3.subquery：包含子查询SQL中的子查询（非最外层）<br><br> 4.simple：简单查询（不包含子查询、union）<br><br> 5.derived：衍生查询（使用到了临时表）<br><br> 6.union：当查询时用到了table1 union table2，table1类型是derived，table2的类型是union<br><br> 7.union result：哪些表存在union查询<br><br> table：<br> 查询的是哪张表</p><p>type：<br> 索引类型<br> system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all<br> system&gt;const存在于理想状态，实际能达到ref，索引的优化一般到ref为止<br> const：仅仅能查到一条数据的SQL，用于主键索引和唯一索引<br> eq_ref：唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多、不能0）<br> ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行<br> range：检索指定范围的行，where后面是一个范围查询（between，&gt;，&lt;)等。<br> index：查询全部索引中的数据<br> all：查询全部表中的数据<br> possible_keys 可能用到的索引</p><p>key<br> 实际用到的索引</p><p>key_len<br> 索引的长度，用于判断复合索引是否被完全使用</p><p>ref<br> 指明当前表所参照的字段</p><p>rows<br> 被索引优化查询的数据个数（实际通过索引查询到的数据个数）</p><p>Extra<br> using filesort：性能消耗大；需要“额外”的一次排序，常见于orderby语句<br> using temporary：性能损耗大，用到了临时表，一般出现在groupby中<br> using index：性能提升；索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据<br> using where：回表查询；</p></div><p>5.mysql索引优化案例</p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>小高是一个程序员，有一天他的组长让他去优化一个接口，这个接口的查询速度非常慢，小高开始分析这个接口，他先试了一下这个接口的响应时间，大概就是45~50秒之间可以返回响应，<br> 此时他已经知道这个事情不简单了。首先小高从代码的角度考虑，看看有没出现for循环的sql从而导致接口性能下降，果不其然，小高发现在业务逻辑的处理中，有人使用了罕见的for循环sql，小高气不打一处来，于是看了下代码记录，<br> 发现小寇，小哲，小李都参与过这段代码，心想：果然石山不是一天累计起来的呀！小高把for循环的sql，拿出来一次性查出来之后，通过代码去处理业务逻辑，进行数据的组装。之后又查看了sql，映入眼帘的就是select * ，话不多说，小高直接就是改成了select 要用到的字段，<br> 因为select * 全表扫描的时候 如果没有索引那么效率会非常低，而且SELECT *操作在某些情况下可能会导致回表。解决完select * 之后小高又到数据库通过执行计划EXPLAIN查看sql的执行情况，发现sql的索引都没有加，小高没有直接去加索引，而是排查了一下sql是否有模糊查询，使用函数等导致索引失效的情况，<br> 在这之后小高直接就是加上了一个联合索引，最终也是顺利的完成了这次优化。</p></div>`,24),i=[t];function l(p,b){return n(),r("div",null,i)}const d=e(a,[["render",l],["__file","MysqlIndex.html.vue"]]);export{d as default};

import{_ as c,a as l}from"./7-b15f98a8.js";import{_ as i,r as o,o as r,c as u,a as n,b as s,d as a,f as e}from"./app-314de074.js";const d={},k=e(`<h1 id="threadpool" tabindex="-1"><a class="header-anchor" href="#threadpool" aria-hidden="true">#</a> ThreadPool</h1><p>池化思想：线程池、字符串常量池、数据库连接池<br> 线程池优点：<br><strong>提高线程得利用率</strong><br><strong>提高程序得响应速度</strong><br><strong>便于统一管理线程对象</strong><br><strong>可以控制最大并发数</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@author</span> kz 单例模式 IoDh实现，静态内部类
 * <span class="token keyword">@date</span> 2022/10/12
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolSingle</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">;</span>
    <span class="token comment">//1.私有化构造器</span>
    <span class="token keyword">private</span> <span class="token class-name">ThreadPoolSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        executor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//2.静态内部类</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadInner</span><span class="token punctuation">{</span>
        <span class="token comment">//3.完成当前对象的实例化</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadPoolSingle</span> poolSingle<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//4.提供公有方法，外键获取对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadPoolSingle</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">ThreadInner</span><span class="token punctuation">.</span>poolSingle<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一、线程池7大参数" tabindex="-1"><a class="header-anchor" href="#一、线程池7大参数" aria-hidden="true">#</a> 一、线程池7大参数</h2><p>1.<strong>核心线程数</strong>，最小线程数<br> 2.<strong>最大线程数</strong>，线程池最多可以创建的线程数量<br> 3.<strong>线程的空闲时间</strong>(回收线程)<br> 4.<strong>空闲时间的单位</strong><br> 5.<strong>阻塞队列</strong>，如果当前任务超过核心线程数，就会放到阻塞队列中<br> 6.<strong>线程工厂</strong>，创建线程<br> 7.<strong>拒绝策略</strong>，如果当前线程池 数量已达上线，就会触发拒绝策略</p><h2 id="二、线程池的运行过程" tabindex="-1"><a class="header-anchor" href="#二、线程池的运行过程" aria-hidden="true">#</a> 二、线程池的运行过程</h2><p>当创建线程池得时候就已经存在了核心线程？<br> 1.当有任务进来得时候，就会先走核心线程，如果任务超过核心线程得数量<br> 2.就会存到阻塞队列中（先进先出）,如果任务过多，超出阻塞队列的最大容量<br> 3.阻塞队列容量已满，线程池验证当前线程是否达到最大限制，如果没有就创建线程，处理新的任务,不是处理阻塞队列得任务.相当于插队<br> 4.当阻塞队列已满并且线程池已达最大线程数得时候（阻塞队列+最大线程数(包含核心线程)）新的任务会触发拒绝策略<br> 5.当任务处理完毕得时候，在设置得回收时间内，没有用到除核心线程以外，已经被创建得线程，就会对改线程进行回收。</p><h2 id="三、阻塞队列" tabindex="-1"><a class="header-anchor" href="#三、阻塞队列" aria-hidden="true">#</a> 三、阻塞队列</h2><p>任务队列是基于阻塞队列实现的，即采用生产者消费者模式，在 Java 中需要实现 BlockingQueue 接口。但 Java 已经为我们提供了 7 种阻塞队列的实现：</p><ol><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列（数组结构可配合指针实现一个环形队列）。</li><li>LinkedBlockingQueue： 一个由链表结构组成的有界阻塞队列，在未指明容量时，容量默认为 Integer.MAX_VALUE。</li><li>PriorityBlockingQueue： 一个支持优先级排序的无界阻塞队列，对元素没有要求，可以实现 Comparable 接口也可以提供 Comparator 来对队列中的元素进行比较。跟时间没有任何关系，仅仅是按照优先级取任务。</li><li>DelayQueue：类似于PriorityBlockingQueue，是二叉堆实现的无界优先级阻塞队列。要求元素都实现 Delayed 接口，通过执行时延从队列中提取任务，时间没到任务取不出来。</li><li>SynchronousQueue： 一个不存储元素的阻塞队列，消费者线程调用 take() 方法的时候就会发生阻塞，直到有一个生产者线程生产了一个元素，消费者线程就可以拿到这个元素并返回；生产者线程调用 put() 方法的时候也会发生阻塞，直到有一个消费者线程消费了一个元素，生产者才会返回。</li><li>LinkedBlockingDeque： 使用双向队列实现的有界双端阻塞队列。双端意味着可以像普通队列一样 FIFO（先进先出），也可以像栈一样 FILO（先进后出）。</li><li>LinkedTransferQueue： 它是ConcurrentLinkedQueue、LinkedBlockingQueue 和 SynchronousQueue 的结合体，但是把它用在 ThreadPoolExecutor 中，和 LinkedBlockingQueue 行为一致，但是是无界的阻塞队列。</li></ol><p><strong>注意有界队列和无界队列的区别：如果使用有界队列，当队列饱和时并超过最大线程数时就会执行拒绝策略；而如果使用无界队列，任务队列永远都可以添加任务，所以设置 maximumPoolSize 没有任何意义</strong></p><h2 id="四、拒绝策略" tabindex="-1"><a class="header-anchor" href="#四、拒绝策略" aria-hidden="true">#</a> 四、拒绝策略</h2><p>ThreadPoolExecutor.<strong>AbortPolicy</strong>: <strong>中止策略 当线程数量大于最大线程时 ，丢弃任务并抛出RejectedExecutionException异常</strong><br> ThreadPoolExecutor.<strong>DiscardPolicy</strong>： <strong>丢弃策略 线程数量大于最大线程时 ，丢弃任务，但是不抛出异常。</strong><br> ThreadPoolExecutor.<strong>DiscardOldestPolicy</strong>： <strong>丢弃最老任务 丢弃队列最前面的任务，重新提交被拒绝的任务</strong><br> ThreadPoolExecutor.<strong>CallerRunsPolicy</strong>： <strong>优先处理策略 由调用线程（提交任务的线程）处理该任务</strong><br><strong>线程池的默认拒绝策略为AbortPolicy 中止策略</strong><br><img src="`+c+'"></p><h3 id="拒绝策略场景分析" tabindex="-1"><a class="header-anchor" href="#拒绝策略场景分析" aria-hidden="true">#</a> 拒绝策略场景分析</h3><h4 id="_4-1abortpolicy-中止策略" tabindex="-1"><a class="header-anchor" href="#_4-1abortpolicy-中止策略" aria-hidden="true">#</a> 4.1AbortPolicy 中止策略</h4><p>如果是比较关键的业务，推荐使用此拒绝策略，<strong>这样在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</strong></p><h4 id="_4-2-discardpolicy-丢弃策略" tabindex="-1"><a class="header-anchor" href="#_4-2-discardpolicy-丢弃策略" aria-hidden="true">#</a> 4.2 DiscardPolicy <strong>丢弃策略</strong></h4><p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。</p><h4 id="_4-3-discardoldestpolicy-丢弃最老任务" tabindex="-1"><a class="header-anchor" href="#_4-3-discardoldestpolicy-丢弃最老任务" aria-hidden="true">#</a> 4.3 DiscardOldestPolicy <strong>丢弃最老任务</strong></h4><p>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量</p><h4 id="_4-4-callerrunspolicy-优先处理策略" tabindex="-1"><a class="header-anchor" href="#_4-4-callerrunspolicy-优先处理策略" aria-hidden="true">#</a> 4.4 CallerRunsPolicy <strong>优先处理策略</strong></h4><p>由调用线程处理该任务</p><h2 id="五、线程池的五大状态" tabindex="-1"><a class="header-anchor" href="#五、线程池的五大状态" aria-hidden="true">#</a> 五、线程池的五大状态</h2>',23),h={href:"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},m=e('<h3 id="_5-1-running" tabindex="-1"><a class="header-anchor" href="#_5-1-running" aria-hidden="true">#</a> 5.1 RUNNING</h3><p>状态说明：在RUNNING状态下，线程池可以接收新的任务和执行已添加的任务。<br> 线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建（比如调Executors.newFixedThreadPool()或者使用ThreadPoolExecutor进行创建），就处于RUNNING状态，并且线程池中的任务数为0！线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理</p><h3 id="_5-2-shutdown" tabindex="-1"><a class="header-anchor" href="#_5-2-shutdown" aria-hidden="true">#</a> 5.2 SHUTDOWN</h3><p>状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务<br> 当一个线程池调用shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN</p><h3 id="_5-3-stop" tabindex="-1"><a class="header-anchor" href="#_5-3-stop" aria-hidden="true">#</a> 5.3 STOP</h3><p>状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在执行的任务<br> 调用线程池的shutdownNow()方法的时候，线程池由(RUNNING或者SHUTDOWN ) -&gt; STOP</p><h3 id="_5-3tidying" tabindex="-1"><a class="header-anchor" href="#_5-3tidying" aria-hidden="true">#</a> 5.3TIDYING</h3><p>状态说明：当所有的任务已终止，记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。<br> 若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重写terminated()函数来实现。 当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，会由STOP -&gt; TIDYING</p><h3 id="_5-4-terminated" tabindex="-1"><a class="header-anchor" href="#_5-4-terminated" aria-hidden="true">#</a> 5.4 TERMINATED</h3><p>状态说明：当钩子函数terminated()被执行完成之后，线程池彻底终止，就变成TERMINATED状态。<br> 线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED<br><img src="'+l+'"></p><h2 id="六、回收核心线程" tabindex="-1"><a class="header-anchor" href="#六、回收核心线程" aria-hidden="true">#</a> 六、回收核心线程</h2><p>//回收核心线程<br> executor.allowCoreThreadTimeOut(true);<br> 使用多线程调用dao层时，新线程于主线程并非同一个上下文，会报空指针异常<br> service 包裹dao</p><h2 id="七、多线程异步定时任务" tabindex="-1"><a class="header-anchor" href="#七、多线程异步定时任务" aria-hidden="true">#</a> 七、 多线程异步定时任务</h2>',13),b=n("br",null,null,-1),v={href:"https://so.csdn.net/so/search?q=Async&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"},g=n("br",null,null,-1),y=n("br",null,null,-1),T=n("strong",null,"SchedulingConfigurer",-1),_=n("br",null,null,-1),w=e(`<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableScheduling</span>
<span class="token annotation punctuation">@EnableAsync</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SchedulerConfig</span> <span class="token keyword">implements</span> <span class="token class-name">SchedulingConfigurer</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configureTasks</span><span class="token punctuation">(</span><span class="token class-name">ScheduledTaskRegistrar</span> taskRegistrar<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        taskRegistrar<span class="token punctuation">.</span><span class="token function">setScheduler</span><span class="token punctuation">(</span><span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>destroyMethod <span class="token operator">=</span> <span class="token string">&quot;shutdown&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token function">taskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadFactory</span> threadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">&quot;schedule-%d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;demoExecutor&quot;</span><span class="token punctuation">,</span> destroyMethod <span class="token operator">=</span> <span class="token string">&quot;shutdown&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token function">demoExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ThreadFactory</span> threadFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">&quot;demoExecutor-%d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Async</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;demoExecutor&quot;</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> timeUnit <span class="token operator">=</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;1111111111111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3);function x(f,N){const t=o("ExternalLinkIcon"),p=o("PDF");return r(),u("div",null,[k,n("p",null,[n("a",h,[s("线程池"),a(t)]),s("的5种状态：Running、ShutDown、Stop、Tidying、Terminated")]),m,n("p",null,[s("为什么使用？"),b,s(" Scheduling 本身是单线程机制，要想多个定时任务并行执行，需要使用 @"),n("a",v,[s("Async"),a(t)]),s(" 注解采用异步执行方式。"),g,s(" 在Spring中，基于@Async标注的方法，称之为异步方法，这些方法将在执行的时候，将会在独立的线程中被执行，调用者无需等待它的完成，即可继续其他的操作。"),y,T,_,s(" 这个注解其实大家并不陌生，如果有使用过 @Scheduled 的话，因为 @Scheduled 默认是单线程执行的，因此如果存在多个任务同时触发，可能触发阻塞。使用 SchedulingConfigurer 可以配置用于执行 @Scheduled 的线程池，来避免这个问题。")]),w,a(p)])}const E=i(d,[["render",x],["__file","ThreadPool.html.vue"]]);export{E as default};

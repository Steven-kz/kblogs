import{_ as e,o as r,c as o,f as s}from"./app-314de074.js";const i={},t=s('<h1 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h1><h3 id="执行流程" tabindex="-1"><a class="header-anchor" href="#执行流程" aria-hidden="true">#</a> 执行流程</h3><p>因为是集群，普遍的锁是无法解决安全问题的，所以用来Redisson的RedLock锁，就是当有两个客户同时购买一个商品的时候，如果不使用分布式锁，就会线程不安全，可能导致出现超卖的现象，然后在那个判断库存上加锁，就是为了防止超卖的，当第一个请求进来的时候，会加锁，使用getLock加锁，锁的是一个key值，这个一般就是商品的id值，当下一个请求进来的时候，就会进不来，直到当前的锁被释放掉，才能重新加锁。</p><h3 id="redisson-看门狗逻辑" tabindex="-1"><a class="header-anchor" href="#redisson-看门狗逻辑" aria-hidden="true">#</a> redisson 看门狗逻辑</h3><p><strong>1、假如我的业务操作比有效时间长，我的业务代码</strong>还没执行完就自动给我解锁了，不就完蛋了吗？<br> 给锁续期。在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。<br></p></div><p><strong>2、如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能？</strong><br></p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。<br> 当持有锁的客户端释放锁的时候，发布锁释放的消息。<br> 当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。</p></div><figure><img src="https://steven-kz.github.io/BlogImgs/imgaes/image-20231011175752580.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h3 id="redis和zookeeper实现分布式锁的区别" tabindex="-1"><a class="header-anchor" href="#redis和zookeeper实现分布式锁的区别" aria-hidden="true">#</a> Redis和Zookeeper实现分布式锁的区别</h3><p>CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><div class="hint-container tip"><p class="hint-container-title">CAP原则上分析</p><p><strong>一致性（C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）<br><strong>可用性（A）</strong>：保证每个请求不管成功或者失败都有响应。<br><strong>分区容忍性（P）</strong>：系统中任意信息的丢失或失败不会影响系统的继续运作。 [1]<br> CAP原则的精髓就是要么AP，要么CP，但是不存在CAP。<br> Redis： AP（保证可用性和分区容错性），Master加锁成功后就给客户端返回成功标识了，而不是等到同步完Slave再发，如果Slave还没同步完成，此时Maste宕机了，就会有问题。<br> Zookeeper ： CP （保证一致性和分区容错性），如果要保证完全一致性，可以使用zookeeper锁，CP，能够保证绝对一致， Zookeeper是Master节点加锁后，把状态也同步到了另外的节点成功后才给客户端返回成功标识但是性能没有redis高</p></div><p><strong>redis和zookeeper技术有何不同？</strong><br> Redis 是nosql数据，主要特点缓存。<br> Zookeeper是分布式协调工具，主要用于分布式解决方案。<br><strong>Redis实现分布式锁与Zookeeper实现分布式锁的思路分别是什么？</strong><br> 获取锁Zookeeper：多个客户端（jvm），会在Zookeeper上创建同一个临时节点，因为Zookeeper节点命名路径保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。<br> Redis：多个客户端（jvm），会在Redis使用setnx命令创建相同的一个key，因为Redis的key保证唯一，不允许出现重复，只要谁能够先创建成功，谁能够获取到锁。<br> 释放锁Zookeeper：使用直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。这时候客户端使用事件监听，如果该临时节点被删除的话，重新进入获取锁的步骤。<br> Redis：在释放锁的时候，为了确保是锁的一致性问题，在删除的redis 的key时候，需要判断同一个锁的id，才可以删除。<br><strong>redis和zookeeper如何解决死锁问题？</strong><br> Zookeeper使用会话有效期方式解决死锁现象。<br> Redis 是对key设置有效期解决死锁现象<br><strong>分别从性能和可靠性两个角度谈谈redis和zookeeper实现分布式锁的优缺点</strong><br> 性能角度考虑：<br> 因为Redis是NoSQL数据库，相对比来说Redis比Zookeeper性能要好。<br> 可靠性：<br> 从可靠性角度分析，Zookeeper可靠性比Redis更好，因为Redis有效期不是很好控制，可能会产生有效期延迟，Zookeeper就不一样，因为Zookeeper临时节点先天性可控的有效期，所以相对来说Zookeeper比Redis更好<br><strong>总结两种方案的优缺点比较</strong><br> 对于redis的分布式锁而言，它有以下缺点：<br> 它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。<br> 另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮<br> 即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking<br> redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。<br> 但是另一方面使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”<br> 所以使用redis作为分布式锁也不失为一种好的方案，最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。<br> 对于zk分布式锁而言:<br> zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。<br> 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。<br> 但是zk也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。</p>',13),n=[t];function d(a,p){return r(),o("div",null,n)}const b=e(i,[["render",d],["__file","RedLock.html.vue"]]);export{b as default};
